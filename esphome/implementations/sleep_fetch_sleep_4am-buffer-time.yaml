
# Problem, the esp32 wakes up at 0350, when it should be waking up at 0400,
# the sleeps for 10 mins and wakes up again.
# We can calculate the number of hours to sleep ourselves, checking if it wokeup too early.

http_request:
  id: fetch_image_request
  timeout: 5s
  useragent: ESP32Display/${display_model}
  verify_ssl: false

deep_sleep:
  id: deep_sleep_control
  run_duration: 1min
  sleep_duration: "86400sec"

time:
  - platform: sntp
    id: time_sntp
    on_time_sync:
      then:
        - logger.log: "Time synchronized! Set sleep and fetch image"
        - script.execute: set_sleep_duration
        - script.execute: set_image_url # update display
        # - script.execute: sleep # aaand sleep

script:
  - id: set_sleep_duration
    then:
      - lambda: |-

          auto now = id(time_sntp).now();

          const uint32_t target_hour = 4; // Wake up at X am
          const uint32_t buffer_hours = 2;
          const uint32_t buffer_seconds = buffer_hours * 3600;
          const uint32_t seconds_in_day = 86400;

          uint32_t current_hour = now.hour;
          uint32_t current_minute = now.minute;
          uint32_t current_second = now.second;
          uint32_t current_timestamp = now.timestamp;

          ESP_LOGD("deep_sleep_calculation", "Current time: %02d:%02d (timestamp: %d)", current_hour, current_minute, current_timestamp);

          uint32_t current_seconds = current_hour * 3600 + current_minute * 60 + current_second;
          uint32_t target_seconds = target_hour * 3600;

          uint32_t seconds_until_target;

          if (
            current_seconds >= (target_seconds - buffer_seconds) &&
            current_seconds < target_seconds
          ) {
            ESP_LOGD("deep_sleep_calculation", "Within buffer, scheduling for tomorrow");
            seconds_until_target = (24 * 3600 - current_seconds) + target_seconds;
          } else if (
              current_seconds < (target_seconds - buffer_seconds)
          ) {
            ESP_LOGD("deep_sleep_calculation", "Target is later today");
            seconds_until_target = target_seconds - current_seconds;
          } else {
            ESP_LOGD("deep_sleep_calculation", "Target already passed, scheduling for tomorrow");
            seconds_until_target = (24 * 3600 - current_seconds) + target_seconds;
          }

          uint32_t sleep_duration_ms = seconds_until_target * 1000;
          ESP_LOGD("deep_sleep_calculation", "Calculated sleep duration: %u seconds (%u ms)", seconds_until_target, sleep_duration_ms);
          id(deep_sleep_control).set_sleep_duration(sleep_duration_ms);


  - id: set_image_url
    then:
      - lambda: |-
          time_t now = id(time_sntp).now().timestamp;
          float voltage = id(battery_voltage).state;

          char buffer[128];
          snprintf(buffer, sizeof(buffer), "?displayModel=%s&time=%d&voltage=%.2f", "${display_model}", (int)now, voltage);
          std::string query = std::string(buffer);

          std::string base_url = "http://homeassistant.local:8090/displays/queue.png";
          id(my_image).set_url(base_url + query);
      - component.update: my_image

logger:
  baud_rate: 115200
  level: DEBUG

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  power_save_mode: light
  on_connect:
    - logger.log: WiFi is connected!
    - logger.log: "Trying to download image"

captive_portal:

online_image:
  - url: "http://homeassistant.local:8090/displays/queue.png" # Default URL, will be overwritten
    id: my_image
    format: png
    type: BINARY
    on_download_finished:
      then:
        - logger.log: "Downloaded image, updating display"
        - display.page.show: page1
        - component.update: my_display
        - delay: 7s
        - deep_sleep.enter:
            id: deep_sleep_control
    on_error:
      then:
        - logger.log: "Error downloading image"
        - display.page.show: page2
        - component.update: my_display
        - delay: 7s
        - deep_sleep.enter:
            id: deep_sleep_control

spi:
  clk_pin: $clk_pin
  mosi_pin: $mosi_pin

display:
  - platform: waveshare_epaper
    id: my_display
    cs_pin: $cs_pin
    dc_pin: $dc_pin
    busy_pin:
      number: $busy_pin
      inverted: $busy_pin_inverted
    reset_pin: $reset_pin
    reset_duration: 200ms
    model: $waveshare_model
    update_interval: never
    pages:
      - id: page1
        lambda: |-
          it.image(0, 0, id(my_image), Color::BLACK, Color::WHITE);
          ESP_LOGD("display", "Image displayed successfully");
      - id: page2
        lambda: |-
          it.line(0, 0, 50, 50);
          it.line(0, 50, 50, 0);
          ESP_LOGD("display", "Error Image displayed successfully");

api:
  on_client_connected:
    then:
      - sensor.template.publish:
          id: battery_level
          state: !lambda "return id(battery_level).state;"
      - sensor.template.publish:
          id: battery_voltage
          state: !lambda "return id(battery_voltage).state;"

ota:
  - platform: esphome

sensor:
  # https://esphome.io/components/sensor/adc.html#measuring-battery-voltage-on-the-firebeetle-esp32-e
  - platform: adc
    id: battery_voltage
    name: "Battery voltage"
    pin: ${vdd_pin}
    accuracy_decimals: 2
    update_interval: 60s
    attenuation: 12dB
    samples: 3
    filters:
      - multiply: 2.0  # The voltage divider requires us to multiply by 2
    on_value:
      then:
        - logger.log: "Battery Voltage: ${sensor.battery_voltage} V"

  - platform: template
    name: "Battery Level"
    id: battery_level
    unit_of_measurement: "%"
    accuracy_decimals: 0
    lambda: |-
      float voltage = id(battery_voltage).state;
      if (voltage < 3.0) return 0;
      if (voltage > 4.2) return 100;
      return (voltage - 3.0) / (4.2 - 3.0) * 100.0;

binary_sensor:
  - platform: status
    name: "${device_id} Status"
    id: device_status
